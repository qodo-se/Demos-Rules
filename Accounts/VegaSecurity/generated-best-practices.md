# [Go]

## General Go Code

- Adhere to `gofmt` for code formatting.
- Follow [Uber's Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md).
- Ensure linting is validated in CI (configured in `.github/workflows/go-lint.yml`).

## Project Structure (services/go)

- Service implementation code resides in dedicated directories.
- `external/`: Contains external APIs (gRPC, Temporal, HTTP) for services. Example: `external/trinomanager/grpc`.
- `tests/integration/`: Houses integration tests.

## Database (gorm & Postgresql)

- For tenant isolation, use `db.GetTenantConnection(ctx, tenant)`. This injects `WHERE tenant_name = ?` and sets `tenant_name` on inserts/updates.

  ```go
  conn := db.GetTenantConnection(ctx, tenant)
  // Use conn for tenant-specific operations
  ```

- Use `db.GetRawConnection(ctx)` only when tenant isolation is not needed (e.g., reading all entries from a table).
- Always check the `.Error` field after gorm operations.

  ```go
  err := conn.Find(&example).Error
  if err != nil {
      // Handle error
  }
  ```

- For database transactions, use `gorm.Transaction` to ensure rollbacks on errors or panics. Do not use `Begin()/Rollback()/Commit()` manually.

  ```go
  err := db.GetTenantConnection(ctx, tenant).Transaction(func(tx *gorm.DB) error {
    // ... perform database operations under transaction
    if someErrorCondition {
      return errors.New("something went wrong")
    }
    return nil
  })
  ```

- Do not place database models in `common/` or `external/` directories. Keep them internal to the service implementation.
- Include database migration files (generated by `scripts/migration_gen.sh` using Atlas) in the same PR as the relevant code changes.

## gRPC

- Store `.proto` files and generated gRPC code in `external/<my-service-name>/`.
- Regenerate gRPC files using `scripts/autogen.sh` after modifying `.proto` files and include them in your PR.

## Pub/Sub Events

- Utilize `common/pubsub/pubsub.go` for implementing pub/sub messaging over PostgreSQL (NOTIFY/LISTEN).
- This mechanism is for decoupled inter-service notification.
- **Important**: Messages are not persistent. If a subscriber is not listening when a message is sent, the message is lost.
- Common use cases include signaling for state resynchronization.
- Example:

  ```go
  // Initialize publisher
  messagesPublisher = pubsub.InitPublisher[string](db)
  // Notify an event
  err := messagesPublisher.Notify(ctx, "channel-name", "tenant-name", "event-payload")

  // Initialize subscriber
  messagesSubscriber, _ = pubsub.InitSubscriber[string](ctx, []string{"channel-name"}, db.GetConnectionURL())
  // Subscribe to a channel for a tenant
  eventChannel, _ := messagesSubscriber.Subscribe("tenant-name")
  // Process messages
  for msg := range eventChannel {
      // Handle msg.Payload
  }
  ```

## GraphQL (gqlgen)

- When defining list types in GraphQL schemas, make the item inside the list non-nullable (e.g., `[Item!]!`).

  ```graphql
  type Query {
    authors: [Author!]! # Author is non-nullable in the list
  }
  ```

- Separate GraphQL schema definitions into different `.graphql` files when adding new types for better organization.
- Implement resolvers generated by `gqlgen` (via `scripts/autogen.sh`).
- For performance in resolvers handling lists of lists, use batching via `common/batch/batching.go`.

  ```go
  // Example: Batch loading books for authors
  batch.GetList(ctx, author.Name, batchTriggerFunc, keyExtractorFunc, BatchBooksFromAuthors)
  ```

## Authentication & Authorization

- Use GraphQL directives for fine-grained authorization. Example: `@authorize(permissions: [DataSourceRead])`.

  ```graphql
  type Query {
    dataSource(id: ID): [DataSource!] @authorize(permissions: [DataSourceRead])
  }
  ```

- When adding new permissions:
    1. Modify `scripts/generate_permissions/permissions.yml`.
    2. Run `scripts/autogen.sh`.
    3. Add the permission to the relevant role in Descope.

## Temporal

- Ensure Temporal workflows are pure functions (no side-effects).
- Execute side-effects within Temporal activities.
- **Always** set a `StartToCloseTimeout` for activities, as the default is unlimited.

  ```go
  ctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
      StartToCloseTimeout: time.Minute * 15,
      RetryPolicy: &temporal.RetryPolicy{ /* ... */ },
  })
  ```

- Use Temporal judiciously due to its power and potential for misconfiguration issues.

## Error Handling

- For errors exposed to users, use `vegaErrors.NewExposedError(ctx, code, err)` or `vegaErrors.NewExposedErrorf(ctx, code, format, args...)`.

  ```go
  // Basic exposed error
  return vegaErrors.NewExposedError(ctx, vegaErrors.ErrorCode_INVALID_INPUT, err)
  
  // Exposed error with arguments
  return vegaErrors.NewExposedError(ctx, vegaErrors.ErrorCode_RESOURCE_NOT_FOUND, err).Arg("resource_id", id)
  ```

- Always wrap errors from external packages before returning them.
  - Temporal activities: `temporal.New*`
  - Gin requests: `response.NewUnauthorizedError`, `response.NewOK`
  - General use: `fmt.Errorf`, `errors.New`, `errors.Unwrap`, `errors.Join` (or equivalent like `pkgErrors.Wrap` if a specific library is used).

## Logging & Tracing (Datadog & zerolog)

- Use `logger.Get(ctx)` to get a logger instance that attaches the trace ID from the context.

  ```go
  log := logger.Get(ctx)
  log.Info().Msg("Processing request")
  ```

- Always provide a `context.Context` to functions where possible to enable trace propagation. Use `http.NewRequestWithContext` instead of `http.NewRequest`.
- For Temporal workflows (where `context.Context` is not directly available for logging in the same way), use `logger.GetWorkflowLogger()`.
- For rate-limiting logs, use `logger.GetRateLimitted(ctx, interval)`.

  ```go
  // Log "hello world" at most once every 5 seconds
  l := logger.GetRateLimitted(ctx, 5 * time.Second)
  l.Warn().Msg("hello world")
  ```

## Module Boundaries & Docker

- Enforce service separation by ensuring Dockerfiles (e.g., `infra/docker/go/gateway/Dockerfile`) only copy necessary directories: the service's own code, `common/`, and `external/`. This prevents direct imports of other services' internal implementations.

## Integration Tests

- Use `require.*` assertions (e.g., `require.NoError(t, err)`) when a failure should stop the test immediately.
- Use `assert.*` assertions (e.g., `assert.Equal(t, expected, actual)`) when the test can continue after a failure.
- Use `t.Logf()` for logging within tests to ensure proper output formatting when tests run in parallel. Do not use `zerolog` or custom loggers directly in tests.

# [Python]

- (To be filled with Python-specific best practices when introduced for AI devs)
- Ensure new Python services replicate relevant guardrails and abstractions from the Go ecosystem (e.g., pub/sub, error handling), implemented lazily as needed.
- Prefer typed languages. If Python is used, leverage type hints extensively.
